import React, {Component} from 'react';
import Layout from '../components/Layout';
import CryptoJS from 'crypto-js'; // This is for the MD5 hash

export default class Upload extends Component{

  constructor(props){
    super(props);
    this.fileThing = {}; // Store the upload file temporarily and bring it to class scope
    this.connection = {}; // Connection holder for websocket
    this.serverIp = "localhost";
    this.setUpWebSocket();
  }

  // Sets up the communication for the backend
  setUpWebSocket = () => {
    window.WebSocket = window.WebSocket || window.MozWebSocket;
    if (!window.WebSocket) {
      console.log("No WebSocket available");
      alert('no websocket available');
      return;
    }
    this.connection = new WebSocket('ws://'+this.serverIp+':13379');
    this.connection.onopen = function () {};
    this.connection.onmessage = function(message) {
      try {
        var command = JSON.parse(message.data || message.utf8Data);
        if (command.hasOwnProperty('filename'))
        {
          for (var i = 0; i < command.length; i++) {
            console.log("Filename: " + command.filename);
          }
        }

      } catch ( e) {
        alert('error: ' + e);
        console.log( e);
        return;
      }
    };
  }

  // This is a necessary function to be able to send the file over as binary, but there's issues
  convertDataURIToBinary = (dataURI) =>{
    //readAsDataURL(file);
/*
    var BASE64_MARKER = ';base64,';

//function convertDataURIToBinary(dataURI) {
    var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
    var base64 = dataURI.substring(base64Index);
    var raw = window.atob(base64);
    var rawLength = raw.length;
    var array = new Uint8Array(new ArrayBuffer(rawLength));

    for(i = 0; i < rawLength; i++) {
      array[i] = raw.charCodeAt(i);
    }
    return array;
*/
  }

  // Helper function to
  convertDataURIToBinaryString = (dataURI) =>{
    //readAsDataURL(file);
    /*
    var BASE64_MARKER = ';base64,';

//function convertDataURIToBinary(dataURI) {
    var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
    var base64 = dataURI.substring(base64Index);
    var raw = window.atob(base64);
    var rawLength = raw.length;
    var array = new Uint8Array(new ArrayBuffer(rawLength));

    for(i = 0; i < rawLength; i++) {
       =  raw.charCodeAt(i);
    }
    return array;
    */
  }

  // Once the file has been selected, this event triggers which parses the file
  checkUploadFile = (event) =>{
    var fr;
    console.log(event);
    console.log(event.target);
    var thing = event.target;
    if('files' in thing){
      if (thing.files.length === 0) {
        console.log("Select one or more files.");
      } else {
        for (var i = 0; i < thing.files.length; i++) {

          var file = thing.files[i]; // Select the file one by one to store for sending

          this.fileThing = {file: 0, filename: "", size: "", lastModifiedDate: "", hash: "", type: "", comment: ""};
          console.log(file);

          // Sets the filename
          if ('name' in file) {
            this.fileThing.file = file;
            console.log("name: " + file.name);
            this.fileThing.filename = file.name;
          }

          // Sets the filesize from the file
          if ('size' in file) {
            console.log("size: " + file.size + " bytes");;
            this.fileThing.size = file.size;
          }

          // Sets the hash
          if ('name' in file) {

            event.preventDefault();
            var reader = new FileReader();

            var md5 = "";
            reader.onload = function(event) {
              var binary = event.target.result;
              md5 = CryptoJS.MD5(binary).toString()
              console.log(md5);
              this.fileThing.hash = md5;
            };

            reader.readAsBinaryString(file);

            // Handle async call
            setInterval(() => {
              this.fileThing.hash = md5;
            }, 10);

          }

          // Sets lastModifiedDate from the modified date of file
          if ('lastModifiedDate' in file) {
            console.log("lastModifiedDate: " + file.lastModifiedDate);
            this.fileThing.lastModifiedDate = file.lastModifiedDate;
          }

          // Sets the type of file from the file
          if ('type' in file) {
            console.log("type: " + file.type);
            this.fileThing.type = file.type;
          }
          this.fileThing.comment = "Random comment";
        }
      }
    }
  }

  // This sends the file data to the backend
  sendData = () => {
    if (this.fileThing != null){
      this.connection.send(JSON.stringify(this.fileThing));
      //this.connection.send(JSON.stringify(login));
      //this.connection.send(JSON.stringify(login));
    }
    this.connection.send(JSON.stringify({command: "read_array"}));
    //alert(JSON.stringify(this.fileThing));
    //event.preventDefault();
    window.location.href = ('/home');
  }

  // Render the upload
  render(){
    return(
      <div className="Upload">
      <Layout>
        <input type="file" id="myFile" multipleSize="1" onChange={this.checkUploadFile}/>
        <button ref="uploadBtn" onClick={this.sendData}>upload</button>
      </Layout>
    </div>
    );
  }
}

/*

Previous attempt at file upload
<FileUpload options={this.uploadOptions} ref="fileUpload">
  <input type="text" name="filename"></input>


</FileUpload>
 */

/*
<form>
  FileName:
  <input type="text" name="filename"></input>
</form>
<button onClick={this.openFile}>GrabFile</button>
<button>Upload</button>
*/

/*
_c: 'file',
_a: 'UploadFile'
},
multiple: true,
numberLimit: this.getLimitNumber,
accept: '/*',
fileFieldName(file) {
  return file.rawID
},
chooseAndUpload: true,
wrapperDisplay: 'block',
beforeUpload: this.checkUploadFile,
uploading: this.handleUploading,
//xhr success
uploadSuccess: this.handleUploadSuccess,
//xhr fail
uploadFail: this.handleUploadFailed,
uploadError: this.handleUploadFailed
}
 */
